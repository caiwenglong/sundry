import{_ as e,o,c as s,O as c}from"./chunks/framework.5a3b7e7e.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vite/vitePreBuild.md"}'),a={name:"interview/vite/vitePreBuild.md"},n=c(`<h3 id="vite-预构建" tabindex="-1">Vite 预构建 <a class="header-anchor" href="#vite-预构建" aria-label="Permalink to &quot;Vite 预构建&quot;">​</a></h3><p>开发阶段 <code>Vite</code> 会对项目中使用的第三方依赖如 <code>lodash-es</code> 等做<code>预构建</code>操作。 之所有要做<code>预构建</code>，是因为<code>Vite</code>是居于浏览器原生的<a href="https://juejin.cn/post/7147610165997469703" target="_blank" rel="noreferrer">ESM规范</a>来实现的，这就要求整个项目的代码必须符合<code>ESM规范</code>。</p><p>而我们在开发中无法保证第三方依赖依赖会严格按照<code>ESM规范</code>来做，所以这就需要我们通过预构建功能将非<code>ESM规范</code>转为符合<code>ESM规范</code>的代码。</p><p>另外，就算有些第三方依赖已经符合<code>ESM规范</code>，但它可能由多个子文件组成，如<code>lodash-es</code>,如果不做处理直接使用，那么就会引发请求瀑布流（<code>如果对lodash-es进行处理， 那么浏览器会发起几百次请求</code>），这将会非常影响页面性能，因此，通过<code>Vite</code>的<code>预构建</code>功能，将第三方依赖内部的多个文件合并为一个，来减少<code>http</code>请求的数量，从而优化页面加载速度。</p><p><strong>综上所述，<code>预构建</code>主要做了两件事：</strong><strong>1. 将非<code>ESM规范</code>的代码转成符合<code>ESM规范</code>的代码</strong><strong>2. 将第三方依赖内部的多个文件合并为一个，减少<code>http</code>请求数量</strong></p><p><strong>示例：</strong> 在<code>vite.config.ts</code>配置文件中，我们将<code>optimizeDeps.exclude</code>的值设置为[&#39;lodash-es&#39;],也就是说我们将不对<code>lodash-es</code>进行预构建</p><div class="language-ts line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">defineConfig</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">plugins</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#82AAFF;">vue</span><span style="color:#A6ACCD;">()]</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">optimizeDeps</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">exclude</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">lodash-es</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>发送请求如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84bb36dfd8e844f79227814da012b096~tplv-k3u1fbpfcp-watermark.image?" alt="2022-09-26_200527.png"></p><p>如果我们将<code>optimizeDeps</code>去掉，<code>Vite</code>默认会对第三方依赖进行预构建，发送请求次数如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b291e4e92a54097aa35da63b014ad23~tplv-k3u1fbpfcp-watermark.image?" alt="2022-09-26_201142.png"></p><p>对比可发现，进行预构建的效果是非常显著的。</p><p>默认情况下，<code>预构建</code>结果会保存到 <code>node_modules</code> 的 <code>.vite/deps</code> 目录下。 当我们重复启动项目时，那么 <code>Vite</code> 会复用上一次<code>预构建</code>的结果。如果不想让 <code>Vite</code> 复用上一次<code>预构建</code>的结构，我们可以配置 <code>optimizeDeps.force</code> 为 <code>true</code>，使得 <code>dev server</code> 每次启动的时候都强制进行<code>预构建</code>。</p><h3 id="vite是怎么做到快速识别项目中的第三方依赖呢" tabindex="-1"><code>Vite</code>是怎么做到快速识别项目中的第三方依赖呢？ <a class="header-anchor" href="#vite是怎么做到快速识别项目中的第三方依赖呢" aria-label="Permalink to &quot;\`Vite\`是怎么做到快速识别项目中的第三方依赖呢？&quot;">​</a></h3><p><code>预构建</code>，最关键的一步就是找到项目中所有的第三方依赖。 那 <code>Vite</code> 是怎么做到快速获取项目中所有的第三方依赖呢？</p><p><code>Vite</code> 借助 <code>ESbuild</code> 快速打包的能力，对整个项目进行一个全量打包，打包的时候通过分析 <code>依赖关系</code>，得到项目中所有源文件的URL，然后分离出第三方依赖，流程大致如下：</p><ol><li>找到入口文件 <code>entry</code> 对应的 <code>url</code>, 这个 <code>url</code> 一般为相对路径；</li><li>将 <code>url</code> 解析为绝对路径，找到源文件在本地磁盘的位置，并构建一个 <code>module</code> 对象；</li><li>读取源文件的内容；</li><li>将源文件内容解析为 <code>AST</code> 对象，分析 <code>AST</code> 对象，找到源文件中的<code>静态依赖</code>(import xxx from &#39;xxx&#39;) 和<code>动态依赖</code>(import(&#39;xx&#39;))对应的 <code>url</code>, 并收集到 <code>module</code> 对象中；</li><li>遍历第 4 步收集到的<code>静态依赖</code>、<code>动态依赖</code>对应的 <code>url</code>，重复 2 - 5 步骤，直到项目中所有的源文件都遍历完成。</li></ol><p>这样，<code>Vite</code> 就可以对找到的第三方依赖做转化、合并操作了。</p><p><code>预构建</code>功能非常棒，但在实际的项目中，并不能保证所有的第三方依赖都可以被找到。如果出现下面的这两种情况， <code>Esbuild</code> 也无能为力:</p><ul><li><code>plugin</code> 在运行过程中，动态给源码注入了新的第三方依赖；</li><li><code>动态依赖</code>在代码运行时，才可以确定最终的 <code>url</code>；</li></ul><p>当出现这两种情况时，<code>Vite</code> 会触发<code>二次预构建</code>：</p><ol><li><code>plugin</code> 在运行过程中，动态给源码注入了新的第三方依赖；</li><li><code>动态依赖</code>在代码运行时，才可以确定最终的 <code>url</code>；</li></ol><p><br> 作者：百应前端团队<br> 链接：<a href="https://juejin.cn/post/7128212841064038414%5C" target="_blank" rel="noreferrer">https://juejin.cn/post/7128212841064038414\\</a> 来源：稀土掘金</p>`,23),d=[n];function p(l,t,r,i,u,D){return o(),s("div",null,d)}const y=e(a,[["render",p]]);export{b as __pageData,y as default};
